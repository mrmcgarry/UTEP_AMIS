var _RawFlowData = [];
var _TrafficHash = [];
var _AvailMarkerIcon = 0;

queue()	// Will load the following instructions until after the page has loaded

.defer(d3.csv, "../data/countries.csv", function(d) {	// d3.csv will be the function that will be called when the page has finished loading
  return {
    latitude: +d.latitude,		// This callback functions modifies the content generated by d3.csv, in this case it parses all the numbers
    longitude: +d.longitude,
	name: d.name
  };
})
//.defer(d3.json, "../data/instrumentData2.json") // d3.json will automatically parse the json object so no callback is necessary in this case
.await(function(error, file1) { 	// Sets the callback to be invoked when all deferred tasks have finished, i.e., the callback function will execute after d3.csv and its callback are executed.

	if(error)
		alert("Something went wrong! :( " + error);	// Alert of any errors with the retrieving of data.

	//console.log(file2);		// Log the resulting JSON object that results from the defered d3.csv method.
	
	var countryCoordData = file1; // The first file that was transferred is the geological position for the countries
	
	var continentCoordData = [
			{latitude: 2.0000003, longitude: 15.9999997, name: "Africa"},
			{latitude: -82.108182, longitude: 34.378236, name: "Antarctica"},
			{latitude: 56.0000002, longitude: 103.9999998, name: "Asia"},
			{latitude:  51.0000003, longitude: 9.9999997, name: "Europe"},
			{latitude: 51.0000002, longitude: -109.0000002, name: "North America"},
			{latitude: -18.3128, longitude: 138.5156, name: "Oceania"},
			{latitude: -21.0002179, longitude: -61.0006565, name: "South America"},
		];
	
	getDataList();
	
	var mymap = renderMap("mapContainer",0,0,2);
	
	getTrafficData("instrumentData2", mymap, "instrumentData2", countryCoordData, continentCoordData);
});

function getDataList()
{
    // Obtain a list of plottable JSON objects from the data folder
    $.ajax(
    {
        type: "GET",
        url: "data/dataList.txt",
        dataType: "text",
        success: getDataListSuccess,
        error: getDataListError,
		statusCode: {
			404: function(){
				alert("File not found");
			}
		}
    }
    );  

}

function getDataListSuccess(data,textStatus,jqXHR)
{ 
    var dataArray = [];
	if(data != null)
    {
		dataArray = data.split("\n"); // Make an array out of the contents of list
		
		$('#dataSel').find('option').remove().end();	// Remove all options in the select box
		$.each(dataArray, function (i, item) {			// Populate select box with the items in the data list
			$('#dataSel').append($('<option>', { 
				value: item,
				text : item 
			}));
		});
		
		$('#dataSel').val('instrumentData2').change();
		document.getElementById("dataSel").selectedIndex=1;
		
		$('#dataSel').off();
		$('#dataSel').on('change', function(){			// When the dropdown changes, the load button will be "clicked"
			//console.log($('#dataSel').val());
			$('#loadButt').trigger('click');
		});
    }
}

function getDataListError(jqXHR,textStatus)
{
    alert("Error reading data list, no data retrieved.");
}

function getTrafficData(fileName, leafletMAP, previousDataset, countryCoordData, continentCoordData)
{
	var filePath = "data/"+fileName+".json";
	// Obtain the instrument data json file from the data directory
	
	$.ajax(
	{
		type: "GET",
		url: filePath,
		dataType: "json",
		//success: getTrafficDataSuccess,
		success: function(data) {
			_RawFlowData = data;
			makeTrafficLayer(data, leafletMAP, previousDataset, countryCoordData, continentCoordData);
		},
		error: getTrafficDataError,
	}
	).responseJSON;  
}

function getTrafficDataError(jqXHR,textStatus)
{
	//console.log(jqXHR,textStatus);
	alert("Error reading JSON, code: " + textStatus.status + " " + jqXHR);
}

function makeTrafficLayer (data, map, prevdataset, countryCoordData, continentCoordData) {
	if(data != null)
	{	/* Note: All variables declared without var are declared like this to allow deletion. */		
		//console.log(data, map, prevdataset, countryCoordData, continentCoordData);
		if (typeof traffic !== 'undefined') 
			delete traffic;
		if (typeof currentlayer !== 'undefined') {
			map.removeLayer(currentlayer);
			delete currentlayer;
		}
		// Remove all event listeners binded by $.on() from all input elements.
		//$('fieldset.vizField').off('input'); 
		tufteLvl = $('#tuftelvlsel').val();
		
		document.getElementById("vizSelectGeo").selectedIndex=0;
		currentlayer = 0; // Allows deletion.
		traffic = 0; // Allows deletion.
		jason = data;
		section = "continentMatrixByte",	// The section of the data that will be represented on the map
		sectionLabel = "continentLbl",		// The label data
		coordinates = continentCoordData,
		maxdiameter = 1000000,
		histocheck = document.getElementById("histCheck").checked,
		appcheck = document.getElementById("appCheck").checked;
	
		traffic = buildHash (jason,section,sectionLabel, coordinates, { getHistData: (histocheck)? true:false, appNames: (histocheck&&appcheck)? true:false });
	
		switch(tufteLvl){
			case "0":
				currentlayer = drawTrafficPaths (traffic, map, { weightRange: [7, 20], diameterRange: [3, maxdiameter], getHistogram: histocheck, colorScale: "default", tuftelvl: "0" });
				break;
			case "1":
				currentlayer = drawTrafficPaths (traffic, map, { weightRange: [3, 10], diameterRange: [3, maxdiameter], getHistogram: histocheck, colorScale: "default", tuftelvl: "1" });
				break;
			case "2":
				currentlayer = drawTrafficPaths (traffic, map, { weightRange: [3, 10], diameterRange: [3, maxdiameter], getHistogram: histocheck, colorScale: "custom", colorScaleRange: ["#800080", "#29a329"], tuftelvl: "2" });
				break;
			default:
				break;
		}
	
		//currentlayer = drawTrafficPaths (traffic, map, { weightRange: [7, 20], diameterRange: [3, maxdiameter], getHistogram: histocheck });
		console.log(tufteLvl);
		currentlayer.addTo(map);
		//console.log("Called");
	}
	$('#histCheck').off();
	$('#histCheck').on('change', function(e){
		d3.select("#vizContainer svg").remove();
		if (typeof traffic !== 'undefined') delete traffic;
		if (typeof currentlayer !== 'undefined') {
			map.removeLayer(currentlayer);
			delete currentlayer;
		}
		
		//document.getElementById("vizSelectGeo").selectedIndex=0;

		histocheck = document.getElementById("histCheck").checked,
		appcheck = document.getElementById("appCheck").checked;

		traffic = buildHash (jason,section,sectionLabel, coordinates, { getHistData: (histocheck)? true:false, appNames: (histocheck&&appcheck)? true:false });
		tufteLvl = $('#tuftelvlsel').val();
		//currentlayer = drawTrafficPaths (traffic, map, { weightRange: [7, 20], diameterRange: [3, maxdiameter], getHistogram: histocheck });
		
		switch(tufteLvl){
			case "0":
				currentlayer = drawTrafficPaths (traffic, map, { weightRange: [7, 20], diameterRange: [3, maxdiameter], getHistogram: histocheck, colorScale: "default", tuftelvl: "0" });
				break;
			case "1":
				currentlayer = drawTrafficPaths (traffic, map, { weightRange: [3, 10], diameterRange: [3, maxdiameter], getHistogram: histocheck, colorScale: "default", tuftelvl: "1" });
				break;
			case "2":
				currentlayer = drawTrafficPaths (traffic, map, { weightRange: [3, 10], diameterRange: [3, maxdiameter], getHistogram: histocheck, colorScale: "custom", colorScaleRange: ["#800080", "#29a329"], tuftelvl: "2" });
				break;
			default:
				break;
		}

		currentlayer.addTo(map);
		$('#tuftelvlsel').off();
		$('#tuftelvlsel').on('change', function(){			// When the dropdown changes, the load button will be "clicked"
			//console.log($('#dataSel').val());
			$('#reloadButt').trigger('click');
		});
		$('#loadButt').off();
		$('#loadButt').prop('disabled', false);
		$("#loadButt").on("click", function(e){
			//dataset = document.getElementById("dataSelTxt").value;
			dataset = $('#dataSel').val();
			if(typeof prevdataset !== 'undefined'){
				if (dataset === prevdataset){
					dataset = prompt("Please select a different dataset:");
					d3.select("#vizContainer svg").remove();
					if (typeof traffic !== 'undefined') 
						delete traffic;
					if (typeof currentlayer !== 'undefined') {
						map.removeLayer(currentlayer);
						delete currentlayer;
					}
				}
				else{
					d3.select("#vizContainer svg").remove();
					if (typeof traffic !== 'undefined') 
						delete traffic;
					if (typeof currentlayer !== 'undefined') {
						map.removeLayer(currentlayer);
						delete currentlayer;
					}
				}
			}
			else {
				d3.select("#vizContainer svg").remove();
				if (typeof traffic !== 'undefined') 
					delete traffic;
				if (typeof currentlayer !== 'undefined') {
					map.removeLayer(currentlayer);
					delete currentlayer;
				}
			}
			prevdataset = dataset;
			//document.getElementById("dataSelTxt").value=dataset;
			//$('#dataSel').val() = dataset;
			$('#loadButt').prop('disabled', true);
			$('#loadButt').off();
			getTrafficData(dataset, map, prevdataset, countryCoordData, continentCoordData);
		});
	});
	
	$('#appCheck').off();
	$('#appCheck').on('change', function(e){
		d3.select("#vizContainer svg").remove();
		if (typeof traffic !== 'undefined') delete traffic;
		if (typeof currentlayer !== 'undefined') {
			map.removeLayer(currentlayer);
			delete currentlayer;
		}
		
		//document.getElementById("vizSelectGeo").selectedIndex=0;

		histocheck = document.getElementById("histCheck").checked,
		appcheck = document.getElementById("appCheck").checked;

		traffic = buildHash (jason,section,sectionLabel, coordinates, { getHistData: (histocheck)? true:false, appNames: (histocheck&&appcheck)? true:false });
		tufteLvl = $('#tuftelvlsel').val();
		//currentlayer = drawTrafficPaths (traffic, map, { weightRange: [7, 20], diameterRange: [3, maxdiameter], getHistogram: histocheck });
		
		switch(tufteLvl){
			case "0":
				currentlayer = drawTrafficPaths (traffic, map, { weightRange: [7, 20], diameterRange: [3, maxdiameter], getHistogram: histocheck, colorScale: "default" });
				break;
			case "1":
				currentlayer = drawTrafficPaths (traffic, map, { weightRange: [3, 10], diameterRange: [3, maxdiameter], getHistogram: histocheck, colorScale: "default" });
				break;
			case "2":
				currentlayer = drawTrafficPaths (traffic, map, { weightRange: [3, 10], diameterRange: [3, maxdiameter], getHistogram: histocheck, colorScale: "custom", colorScaleRange: ["#800080", "#29a329"] });
				break;
			default:
				break;
		}

		currentlayer.addTo(map);
		$('#loadButt').off();
		$('#loadButt').prop('disabled', false);
		$("#loadButt").on("click", function(e){
			//dataset = document.getElementById("dataSelTxt").value;
			dataset = $('#dataSel').val();
			
			if(typeof prevdataset !== 'undefined'){
				if (dataset === prevdataset){
					dataset = prompt("Please select a different dataset:");
					d3.select("#vizContainer svg").remove();
					if (typeof traffic !== 'undefined') 
						delete traffic;
					if (typeof currentlayer !== 'undefined') {
						map.removeLayer(currentlayer);
						delete currentlayer;
					}
				}
				else{
					d3.select("#vizContainer svg").remove();
					if (typeof traffic !== 'undefined') 
						delete traffic;
					if (typeof currentlayer !== 'undefined') {
						map.removeLayer(currentlayer);
						delete currentlayer;
					}
				}
			}
			else {
				d3.select("#vizContainer svg").remove();
				if (typeof traffic !== 'undefined') 
					delete traffic;
				if (typeof currentlayer !== 'undefined') {
					map.removeLayer(currentlayer);
					delete currentlayer;
				}
			}
			prevdataset = dataset;
			//document.getElementById("dataSelTxt").value=dataset;
			//$('#dataSel').val() = dataset;
			$('#loadButt').prop('disabled', true);
			$('#loadButt').off();
			getTrafficData(dataset, map, prevdataset, countryCoordData, continentCoordData);
		});
	});
	
	$('#vizSelectGeo').off();
	$("#vizSelectGeo").on("change", function(e){
		d3.select("#vizContainer svg").remove();
		//d3.select("div#mapContainer *").remove();
		if (typeof traffic !== 'undefined') delete traffic;
		if (typeof currentlayer !== 'undefined') {
			map.removeLayer(currentlayer);
			delete currentlayer;
		}
		coordinates = 0;
		
		histocheck = document.getElementById("histCheck").checked;
		appcheck = document.getElementById("appCheck").checked;
		
		section = e.target[e.target.selectedIndex].value;
		if (section === "pkthist" || section === "srcporthist" || section === "dstporthist" || section === "protocolhist"){
			alert("Function not yet supported, displaying continent-level data.");
			section = "continentMatrixByte";
			document.getElementById("vizSelectGeo").selectedIndex=0;
		}
		switch (section) {
			case "continentMatrixByte":
				sectionLabel = "continentLbl";
				coordinates = continentCoordData;
				maxdiameter = 1000000;
				break;
			case "countryMatrixByte":
				sectionLabel = "countryLbl";
				coordinates = countryCoordData;
				maxdiameter = 1000000;
				break;
			default:
				sectionLabel = "asnumOrgname";
				coordinates = 0;
				maxdiameter = 1000;
			}
		
		traffic = buildHash (jason,section,sectionLabel, coordinates, { getHistData: (histocheck)? true:false, appNames: (histocheck&&appcheck)? true:false });
		tufteLvl = $('#tuftelvlsel').val();
		//currentlayer = drawTrafficPaths (traffic, map, { weightRange: [7, 20], diameterRange: [3, maxdiameter], getHistogram: histocheck });
		
		switch(tufteLvl){
			case "0":
				currentlayer = drawTrafficPaths (traffic, map, { weightRange: [7, 20], diameterRange: [3, maxdiameter], getHistogram: histocheck, colorScale: "default", tuftelvl: "0" });
				break;
			case "1":
				currentlayer = drawTrafficPaths (traffic, map, { weightRange: [3, 10], diameterRange: [3, maxdiameter], getHistogram: histocheck, colorScale: "default", tuftelvl: "1" });
				break;
			case "2":
				currentlayer = drawTrafficPaths (traffic, map, { weightRange: [3, 10], diameterRange: [3, maxdiameter], getHistogram: histocheck, colorScale: "custom", colorScaleRange: ["#800080", "#29a329"], tuftelvl: "2" });
				break;
			default:
				break;
		}
		
		currentlayer.addTo(map);
		//console.log(currentlayer);
	});
	$('#killButt').off();
	$('#killButt').prop('disabled', false);
	$("#killButt").on("click", function(e){
		d3.select("#vizContainer svg").remove();
		if (typeof traffic !== 'undefined') delete traffic;
		if (typeof currentlayer !== 'undefined') {
			map.removeLayer(currentlayer);
			delete currentlayer;
		}
		map.eachLayer(function (layer) {
			//console.log(layer);
			if (layer._leaflet_id !== 24)
				map.removeLayer(layer);
		});
		$('#killButt').prop('disabled', true);
	});
	$('#loadButt').off();
	$('#loadButt').prop('disabled', false);
	$("#loadButt").one("click", function(e){
		//dataset = document.getElementById("dataSelTxt").value;
		dataset = $('#dataSel').val();
		if(typeof prevdataset !== 'undefined'){
			while (dataset === prevdataset){
				dataset = prompt("Please select a different dataset:");
			}
			d3.select("#vizContainer svg").remove();
			if (typeof traffic !== 'undefined') 
				delete traffic;
			if (typeof currentlayer !== 'undefined') {
				map.removeLayer(currentlayer);
				delete currentlayer;
			}
		}
		else {
			d3.select("#vizContainer svg").remove();
			if (typeof traffic !== 'undefined') 
				delete traffic;
			if (typeof currentlayer !== 'undefined') {
				map.removeLayer(currentlayer);
				delete currentlayer;
			}
		}
		prevdataset = dataset;
		//document.getElementById("dataSelTxt").value=dataset;
		//$('#dataSel').val() = dataset;
		$('#loadButt').prop('disabled', true);
		$('#loadButt').off();
		getTrafficData(dataset, map, prevdataset, countryCoordData, continentCoordData);
	});
	
	$('#reloadButt').off();
	$("#reloadButt").on("click", function(){
		$('#killButt').prop('disabled', false);
		d3.select("#vizContainer svg").remove();
		if (typeof traffic !== 'undefined') delete traffic;
		if (typeof currentlayer !== 'undefined') {
			map.removeLayer(currentlayer);
			delete currentlayer;
		}
		
		//document.getElementById("vizSelectGeo").selectedIndex=0;

		histocheck = document.getElementById("histCheck").checked,
		appcheck = document.getElementById("appCheck").checked;

		traffic = buildHash (jason,section,sectionLabel, coordinates, { getHistData: (histocheck)? true:false, appNames: (histocheck&&appcheck)? true:false });
		
		tufteLvl = $('#tuftelvlsel').val();
		//currentlayer = drawTrafficPaths (traffic, map, { weightRange: [7, 20], diameterRange: [3, maxdiameter], getHistogram: histocheck });
		
		switch(tufteLvl){
			case "0":
				currentlayer = drawTrafficPaths (traffic, map, { weightRange: [7, 20], diameterRange: [3, maxdiameter], getHistogram: histocheck, colorScale: "default", tuftelvl: "0" });
				break;
			case "1":
				currentlayer = drawTrafficPaths (traffic, map, { weightRange: [3, 10], diameterRange: [3, maxdiameter], getHistogram: histocheck, colorScale: "default", tuftelvl: "1" });
				break;
			case "2":
				currentlayer = drawTrafficPaths (traffic, map, { weightRange: [3, 10], diameterRange: [3, maxdiameter], getHistogram: histocheck, colorScale: "custom", colorScaleRange: ["#800080", "#29a329"], tuftelvl: "2" });
				break;
			default:
				break;
		}

		currentlayer.addTo(map);
		$('#loadButt').off();
		$('#loadButt').prop('disabled', false);
		$("#loadButt").on("click", function(e){
			//dataset = document.getElementById("dataSelTxt").value;
			dataset = $('#dataSel').val();
			if(typeof prevdataset !== 'undefined'){
				if (dataset === prevdataset){
					dataset = prompt("Please select a different dataset:");
					d3.select("#vizContainer svg").remove();
					if (typeof traffic !== 'undefined') 
						delete traffic;
					if (typeof currentlayer !== 'undefined') {
						map.removeLayer(currentlayer);
						delete currentlayer;
					}
				}
				else{
					d3.select("#vizContainer svg").remove();
					if (typeof traffic !== 'undefined') 
						delete traffic;
					if (typeof currentlayer !== 'undefined') {
						map.removeLayer(currentlayer);
						delete currentlayer;
					}
				}
			}
			else {
				d3.select("#vizContainer svg").remove();
				if (typeof traffic !== 'undefined') 
					delete traffic;
				if (typeof currentlayer !== 'undefined') {
					map.removeLayer(currentlayer);
					delete currentlayer;
				}
			}
			prevdataset = dataset;
			//document.getElementById("dataSelTxt").value=dataset;
			//$('#dataSel').val() = dataset;
			$('#loadButt').prop('disabled', true);
			$('#loadButt').off();
			getTrafficData(dataset, map, prevdataset, countryCoordData, continentCoordData);
		});
		
	});		
}

function buildHash ( data, matrix, matrixLabel, coordinateData, options ) {
	//console.log(data);
	var results = [];
	_TrafficHash = [];
		
	function searchCoordinate (term) {
		// SEARCH
		var latlong = [];
		
		for (var j=0; j<coordinateData.length; j++)
		{
			if (coordinateData[j].name === term){
				//latlong = new L.LatLng(coordinateData[j].latitude, coordinateData[j].longitude);
				latlong = [coordinateData[j].latitude, coordinateData[j].longitude];
				break;
			}
			else if (coordinateData[j].name === null){
				latlong = [0,0];
				break;
			}
		}
		return latlong;
	}
	
	if (matrix === 'asMatrixByte'){
		for (var y=0; y<data[matrix].length; y++){
			for (var x=0; x<data[matrix][y].length; x++){				
				results.push({ SrcLabel: data[matrixLabel][y], DstLabel: data[matrixLabel][x], Bytes: data[matrix][y][x],
					SrcLatitude: data['asnumLatitude'][y], 
					SrcLongitude: data['asnumLongitude'][y],
					SrcAS: data['asLbl'][y],
					DstLatitude: data['asnumLatitude'][x],
					DstLongitude: data['asnumLongitude'][x],
					DstAS: data['asLbl'][x],
					/* SrcCoords: searchCoordinate(data[matrixLabel][y]),
					DstCoords: searchCoordinate(data[matrixLabel][x]), */
					X: x, Y: y, offset: (x > y)? 10: 0,
					SrcPort: { Bytes: (options.getHistData)? ((options.appNames)? ((data['asMatrixSrcAppHist'])? data['asMatrixSrcAppHist'][y][x] : 'undefined') : ((data['asMatrixSrcPortHist'])? data['asMatrixSrcPortHist'][y][x] : 'undefined')) : 'undefined', Ports: (options.getHistData)? ((options.appNames)? data['srcAppNames'] : data['srcPortNumbers']) : 'undefined' },
					DstPort: { Bytes: (options.getHistData)? ((options.appNames)? ((data['asMatrixDstAppHist'])? data['asMatrixDstAppHist'][y][x] : 'undefined') : ((data['asMatrixDstPortHist'])? data['asMatrixDstPortHist'][y][x] : 'undefined')) : 'undefined', Ports: (options.getHistData)? ((options.appNames)? data['dstAppNames'] : data['dstPortNumbers']) : 'undefined' },
					HashType: 'Organization'
				});
			}
		}
	}
	else{
		var srclatlong, dstlatlong;
		
		for (var y=0; y<data[matrix].length; y++){
			for (var x=0; x<data[matrix][y].length; x++){
				srclatlong = searchCoordinate(data[matrixLabel][y]);
				dstlatlong = searchCoordinate(data[matrixLabel][x]);
				
				results.push({ SrcLabel: data[matrixLabel][y], DstLabel: data[matrixLabel][x], Bytes: data[matrix][y][x],
					SrcLatitude: srclatlong[0], 
					SrcLongitude: srclatlong[1],
					DstLatitude: dstlatlong[0],
					DstLongitude: dstlatlong[1],
					/* SrcCoords: searchCoordinate(data[matrixLabel][y]),
					DstCoords: searchCoordinate(data[matrixLabel][x]), */
					X: x, Y: y, offset: (x > y)? 10: 0,
					SrcPort: { Bytes: (options.getHistData)?
										(
											(options.appNames)? 
												(
													(matrix === "continentMatrixByte")? 
														data['continentMatrixSrcAppHist'][y][x]
														:data['countryMatrixSrcAppHist'][y][x]
												) 
											:(
												(matrix === "continentMatrixByte")?
													data['continentMatrixSrcPortHist'][y][x] 
													:data['countryMatrixSrcPortHist'][y][x]
											)
										)
										:'undefined',
							   Ports: (options.getHistData)?
										(
											(options.appNames)?
												data['srcAppNames']
												:data['srcPortNumbers']
										)
									   :'undefined' },
					DstPort: { Bytes: (options.getHistData)?
										(
											(options.appNames)? 
												(
													(matrix === "continentMatrixByte")? 
														data['continentMatrixDstAppHist'][y][x]
														:data['countryMatrixDstAppHist'][y][x]
												) 
											:(
												(matrix === "continentMatrixByte")?
													data['continentMatrixDstPortHist'][y][x] 
													:data['countryMatrixDstPortHist'][y][x]
											)
										)
										:'undefined',
							   Ports: (options.getHistData)?
										(
											(options.appNames)?
												data['DstAppNames']
												:data['DstPortNumbers']
										)
									   :'undefined' },
					HashType: 'Continent/Country'
				});
			}
		}
	}
	//console.log(results);
	_TrafficHash = results;
	return results;
}

function renderMap ( container, viewlat, viewlong, zoom ) {
	
	var containerid = "#"+container;
	var mymap = L.map(container).setView([viewlat, viewlong], zoom);
	var tuftelvl = $('#tuftelvlsel').val();
	
	/* Look at https://leaflet-extras.github.io/leaflet-providers/preview/ for tiles */
	
	var colourMap = L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
	attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
	}).addTo(mymap); // Normal openstreetmap
	
	var greyscaleMap = L.tileLayer('http://{s}.tiles.wmflabs.org/bw-mapnik/{z}/{x}/{y}.png', {
	attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
	}); // Black and white openstreetmap
	
	$('#mapTypeCheckC').on('click', function(){
		mymap.removeLayer(greyscaleMap);
		colourMap.addTo(mymap);
	});
	
	$('#mapTypeCheckG').on('click', function(){
		mymap.removeLayer(colourMap);
		greyscaleMap.addTo(mymap);
	});
	
	$("#sizeSliderW").on("input", function(e){
		var size = e.target.value;
		$("#sizeInputW").val(size);
		$(containerid).css({
			"width": size+"%"
		});
	});
	$("#sizeInputW").on("change", function(e){
		var size = e.target.value;
		$("#sizeSliderW").val(size);
		$(containerid).css({
			"width": size+"%"
		});
	});
	$("#sizeSliderH").on("input", function(e){
		var size = e.target.value;
		$("#sizeInputH").val(size);
		$(containerid).css({
			"height": size
		});
	});
	$("#sizeInputH").on("change", function(e){
		var size = e.target.value;
		$("#sizeSliderH").val(size);
		$(containerid).css({
			"height": size
		});
	});
	
	return mymap;
	
}

function drawTrafficPaths ( trafficData, map, options ) {
	
	//console.log(options);
	//var tuftelvl = $('#tuftelvlsel').val;
	
	var weightScale = d3.scale.linear()
		.domain([d3.min(trafficData, function (d){ return d.Bytes; }), d3.max(trafficData, function (d){ return d.Bytes; })]) 
		.range([options.weightRange[0], options.weightRange[1]]);
	
	if (options.colorScale === "default")
		var colourScale = d3.scale.category10();
	else
		var colourScale = d3.scale.ordinal()
		.domain([d3.min(trafficData, function (d){ return d.Bytes; }), d3.max(trafficData, function (d){ return d.Bytes; })]) 
		.range(options.colorScaleRange);
	
	var diameterScale = d3.scale.log()
		.domain([1, d3.max(trafficData, function (d){ return d.Bytes; })]) 
		.range([options.diameterRange[0], options.diameterRange[1]]);
	
	var pointsList = [];
	var markerList = [];
	var polyLineList = [];
	var circlesList = [];
	var animatedMarker = [];
	var thisLayer = L.layerGroup();
	
	for (var i = 0; i<trafficData.length; i++){
		if(trafficData[i].SrcLatitude === undefined || trafficData[i].DstLatitude === undefined || trafficData[i].SrcLongitude === undefined || trafficData[i].DstLongitude === undefined)
			console.log("Undefined coordinates, data skipped. " + "Check spelling on '" + trafficData[i].SrcLabel + "'or '" + trafficData[i].DstLabel + "'.");
		else{
			pointsList.push([new L.LatLng(trafficData[i].SrcLatitude, trafficData[i].SrcLongitude),
							 new L.LatLng(trafficData[i].DstLatitude, trafficData[i].DstLongitude)]);
			/* pointsList.push([trafficData[i].SrcCoords, trafficData[i].DstCoords]); */
		}
	}
	
	for (i = 0; i<trafficData.length; i++){
		if(trafficData[i].SrcLatitude === undefined || trafficData[i].DstLatitude === undefined || trafficData[i].SrcLongitude === undefined || trafficData[i].DstLongitude === undefined)
			console.log("No Path Drawn!" + "(" + trafficData[i].SrcLabel + " to " + trafficData[i].DstLabel + ")");
		else{
			if(trafficData[i].SrcLatitude === trafficData[i].DstLatitude && trafficData[i].SrcLongitude === trafficData[i].DstLongitude && trafficData[i].Bytes)
			//if(trafficData[i].SrcCoords === trafficData[i].DstCoords && trafficData[i].Bytes)
			{
				circlesList.push(new L.circle(pointsList[i][0], diameterScale(trafficData[i].Bytes), {
					color: colourScale(trafficData[i].Bytes),
					fillColor: colourScale(trafficData[i].Bytes),
					fillOpacity: 0.5,
					data: trafficData[i]
				}).bindPopup(trafficData[i].Bytes.toString() + ' bytes within ' + trafficData[i].SrcLabel + '.'));
			}	
			else if (trafficData[i].Bytes)
			{
				polyLineList.push( new L.Polyline(pointsList[i], {
					color: colourScale(trafficData[i].Bytes),
					weight: weightScale(trafficData[i].Bytes),
					opacity: 0.06,
					smoothFactor: 1,
					offset: trafficData[i].offset,
					data: trafficData[i]
				}).bindPopup(trafficData[i].Bytes.toString() + ' bytes from ' + trafficData[i].SrcLabel + ' to ' + trafficData[i].DstLabel + '.'));
			}
		}
	}
	
	function compare(a,b) {
	  if (a._mRadius > b._mRadius)
		return -1;
	  if (a._mRadius < b._mRadius)
		return 1;
	  return 0;
	}
	
	circlesList.sort(compare);

	if(options.getHistogram){
		for (i=0;i<circlesList.length;i++){
			circlesList[i]
			.on('click', function(e){
				//console.log(e.target);
				
				var datax = e.target.options.data.SrcPort.Ports;
				var datay = e.target.options.data.SrcPort.Bytes;
				
				switch(options.tuftelvl){
					case "0":
						plotHistogramRaw( 0.1, "Port", "Bytes", datax, datay, "#vizContainer" );
						break;
					case "1":
						plotHistogramRawLT( 0.1, "Port", "Bytes", datax, datay, "#vizContainer" );
						break;
					case "2":
						plotHistogramRawFT( 0.1, "Port", "Bytes", datax, datay, "#vizContainer" );
						break;
					default:
						break;
				}
			});
			thisLayer.addLayer(circlesList[i]);
		}
	}
	else{
		for (i=0;i<circlesList.length;i++){
			thisLayer.addLayer(circlesList[i]);
		}
	}
	
		if(options.getHistogram){
			for (i=0;i<polyLineList.length;i++){
				polyLineList[i].on('mouseover', function(e){
				var layer = e.target;

				layer.setStyle({
					opacity: 0.8
					});
				})
				.on('mouseout', function(e){
					var layer = e.target;

					layer.setStyle({
						opacity: 0.06
					});
				})
				.on('click', function(e){
					//console.log(e.target);
					
					var datax = e.target.options.data.SrcPort.Ports;
					var datay = e.target.options.data.SrcPort.Bytes;
					
					switch(options.tuftelvl){
					case "0":
						plotHistogramRaw( 0.1, "Port", "Bytes", datax, datay, "#vizContainer" );
						break;
					case "1":
						plotHistogramRawLT( 0.1, "Port", "Bytes", datax, datay, "#vizContainer" );
						break;
					case "2":
						plotHistogramRawFT( 0.1, "Port", "Bytes", datax, datay, "#vizContainer" );
						break;
					default:
						break;
					}
				});
				thisLayer.addLayer(polyLineList[i]);
			}
		}
		else{
			for (i=0;i<polyLineList.length;i++){
				polyLineList[i].on('mouseover', function(e){
					var layer = e.target;

					layer.setStyle({
						opacity: 0.8
					});
				})
				.on('mouseout', function(e){
					var layer = e.target;

					layer.setStyle({
						opacity: 0.06
					});
				})
				.on('popupopen', function(e){
					var layer = e.target;
					
					layer.setStyle({
						pointerEvents: 'none'
					});					
				})
				.on('popupclose', function(e){
					var layer = e.target;
					
					layer.setStyle({
						pointerEvents: 'auto'
					});
				});
				thisLayer.addLayer(polyLineList[i]);
			}
		}
	
	function bindPolyline(e) {
		// SEARCH
		var searchResults = [],
			searchTerm = e.target.getLatLng(),
			compare = [];
		
		for(var i=0;i<polyLineList.length;i++)
		{
			compare = polyLineList[i]._latlngs;
			if (compare[0].equals(searchTerm) || compare[1].equals(searchTerm))
				searchResults.push(polyLineList[i]);
		}
		//console.log(searchResults);
		return searchResults;
	}
	
	function getmarker2(AS)						//function takes in AS# , Latititude, Longitude. in that order
	{													//function will look thru folder 
		var imgPath= "../images/AS_images/"+AS+".png";
		
		$.ajax({
			type: "GET",
			url: imgPath,
			dataType: "html",
			success: function(){
				console.log("Found image!");
				_AvailMarkerIcon = 1;
			},
			error: function(){
				_AvailMarkerIcon = 0;
			},
			async: false
		});
	}
	
	i = 0;
	while(trafficData[i].Y === 0)
	{
		if (trafficData[i].HashType === "Organization" && (options.tuftelvl === "1" || options.tuftelvl === "2")){
			getmarker2(trafficData[i].DstAS);
			if(_AvailMarkerIcon === 1){
				console.log("Logo found!");
				
				logoPath= "../images/AS_images/"+trafficData[i].DstAS+".png";
				orgLogo = L.icon({
						iconUrl:logoPath,
						iconSize:[30,35],							//adjust icon size [a,b]
						inconAnchor:[15,35],						//anchor must be [a*.5,b]
						popupAnchor:[-3,-76]						//popup anchor is optional
					});
				
				markerList[i] = new L.marker(pointsList[i][1], { riseOnHover: true, riseOffset: 200, icon: orgLogo }).bindPopup(trafficData[i].DstLabel+", AS Number: "+trafficData[i].DstAS).on('popupopen', function(e){
					var polylines = bindPolyline(e),
						offsetvalue;
						
					var myIcon = L.icon({
							iconUrl: 'http://geopole.free.fr/exemples/geoportail/jQGeoportail-0/img/marker-icon-purple.png',
							iconSize: [25, 41],
							iconAnchor: [12.5, 41],
						});
					//console.log(polylines[0].getLatLngs(), L.PolylineOffset.offsetLatLngs(polylines[0].getLatLngs(),10,map));
					for(var i=0;i<polylines.length;i++){
						offsetvalue = polylines[i].options.offset;
						polylines[i].setStyle({
							opacity: 0.8
						});
						
						animatedMarker.push(L.Marker.movingMarker(L.PolylineOffset.offsetLatLngs(polylines[i].getLatLngs(),offsetvalue,map), [2000], {
							icon: myIcon,
							autostart: true,
							loop: true
						}));
						for (var j=0;j<animatedMarker.length;j++)
							animatedMarker[j].addTo(map);
					}
				})
				.on('popupclose', function(e){
					//console.log(animatedMarker);
					for (var j=0;j<animatedMarker.length;j++)
						map.removeLayer(animatedMarker[j]);
					animatedMarker = [];
					var polylines = bindPolyline(e);
					for(var i=0;i<polylines.length;i++){
						polylines[i].setStyle({
							opacity: 0.06
						});
					}
				});
			}
			else{
				markerList[i] = new L.marker(pointsList[i][1], { riseOnHover: true, riseOffset: 200 }).bindPopup(trafficData[i].DstLabel+", AS Number: "+trafficData[i].DstAS).on('popupopen', function(e){
					var polylines = bindPolyline(e),
						offsetvalue;
						
					var myIcon = L.icon({
							iconUrl: 'http://geopole.free.fr/exemples/geoportail/jQGeoportail-0/img/marker-icon-purple.png',
							iconSize: [25, 41],
							iconAnchor: [12.5, 41],
						});
					//console.log(polylines[0].getLatLngs(), L.PolylineOffset.offsetLatLngs(polylines[0].getLatLngs(),10,map));
					for(var i=0;i<polylines.length;i++){
						offsetvalue = polylines[i].options.offset;
						polylines[i].setStyle({
							opacity: 0.8
						});
						
						animatedMarker.push(L.Marker.movingMarker(L.PolylineOffset.offsetLatLngs(polylines[i].getLatLngs(),offsetvalue,map), [2000], {
							icon: myIcon,
							autostart: true,
							loop: true
						}));
						for (var j=0;j<animatedMarker.length;j++)
							animatedMarker[j].addTo(map);
					}
				})
				.on('popupclose', function(e){
					//console.log(animatedMarker);
					for (var j=0;j<animatedMarker.length;j++)
						map.removeLayer(animatedMarker[j]);
					animatedMarker = [];
					var polylines = bindPolyline(e);
					for(var i=0;i<polylines.length;i++){
						polylines[i].setStyle({
							opacity: 0.06
						});
					}
				});
			}
		}
		else{
			markerList[i] = new L.marker(pointsList[i][1], { riseOnHover: true, riseOffset: 200 }).bindPopup(trafficData[i].DstLabel+", AS Number: "+trafficData[i].DstAS).on('popupopen', function(e){
				var polylines = bindPolyline(e),
					offsetvalue;
					
				var myIcon = L.icon({
						iconUrl: 'http://geopole.free.fr/exemples/geoportail/jQGeoportail-0/img/marker-icon-purple.png',
						iconSize: [25, 41],
						iconAnchor: [12.5, 41],
					});
				//console.log(polylines[0].getLatLngs(), L.PolylineOffset.offsetLatLngs(polylines[0].getLatLngs(),10,map));
				for(var i=0;i<polylines.length;i++){
					offsetvalue = polylines[i].options.offset;
					polylines[i].setStyle({
						opacity: 0.8
					});
					
					animatedMarker.push(L.Marker.movingMarker(L.PolylineOffset.offsetLatLngs(polylines[i].getLatLngs(),offsetvalue,map), [2000], {
						icon: myIcon,
						autostart: true,
						loop: true
					}));
					for (var j=0;j<animatedMarker.length;j++)
						animatedMarker[j].addTo(map);
				}
			})
			.on('popupclose', function(e){
				//console.log(animatedMarker);
				for (var j=0;j<animatedMarker.length;j++)
					map.removeLayer(animatedMarker[j]);
				animatedMarker = [];
				var polylines = bindPolyline(e);
				for(var i=0;i<polylines.length;i++){
					polylines[i].setStyle({
						opacity: 0.06
					});
				}
			});
		}
		thisLayer.addLayer(markerList[i]);
		i++;
	}
	
	return thisLayer;

}

function drawMatrix ( container, trafficData ) {
	
	var uniqueNames = [];
	
	for ( var i = 0; i<trafficData.length; i++ ){
		uniqueNames.push(trafficData[i].SrcLabel);
	}
	
	$.uniqueSort(uniqueNames);

	var weightScale = d3.scale.log()
		.domain([1, d3.max(trafficData, function (d){ return d.Bytes; })]) 
		.range([0.1, 1]),
		
		colourScale = d3.scale.category10(),
		
		nameScaleSize = trafficData.length * 4.2,
		nameScale = d3.scale.ordinal()
					.domain(uniqueNames)
					.rangePoints([0,nameScaleSize],1);
	
	var svg = d3.select(container)
		.append("svg")
		.attr("height", 2000)
		.attr("width", 2000)
		.attr("id", "matrixsvg");
		
/* 	svg.append("rect")
		.attr("width", 500)
		.attr("height", 500)
		.attr("fill", "rgba(100,100,100,0.4)")
		.attr("class", "backgroundColor"); */
		
	var g = svg.append("g")
		.attr("transform", "translate(150,150)")
		.attr("id", "adjacencyG");
		
	g.selectAll("rect")
		.data(trafficData)
		.enter()
		.append("rect")
		.attr("class", "grid")
		.attr("width", 25)
		.attr("height", 25)
		.attr("x", function (d) { return d.X * 30 })
		.attr("y", function (d) { return d.Y * 30 })
		.attr("fill", function (d) { return (d.Bytes) ? "purple" : "blue" })
		.attr("stroke", function (d) { return (d.Bytes) ? "purple" : "blue" })
		.attr("rx", 5)
		.attr("ry", 5)
		.style("fill-opacity", function (d) { return weightScale(d.Bytes); } )
		.on("mouseover", showLabel)
		.on("mouseout", clearLabel);
			
	function showLabel (d) {
		g.append("text")
			.attr("class", "mlabel")
			.attr("x", d.X * 30 )
			.attr("y", d.Y * 30 )
			.attr("text-anchor", "middle")
			.text(d.Bytes)
			.attr("transform", "translate(13,17)");
	}
	
	function clearLabel (d) {
		d3.select(".mlabel").remove();
	}
	
	var xAxis = d3.svg.axis().scale(nameScale).orient("top").tickSize(0),   
		yAxis = d3.svg.axis().scale(nameScale).orient("left").tickSize(0);    
	
	d3.select("#adjacencyG").append("g").call(xAxis).selectAll("text").style("text-anchor", "start").attr("transform", "translate(10, -10) rotate(-90)");
	d3.select("#adjacencyG").append("g").call(yAxis);
}

function getContinentData()
{
    // Obtain the continent geojson file from the data directory
    $.ajax(
    {
        type: "GET",
        url: "data/continents.json",
        dataType: "json",
        success: getContinentDataSuccess,
        error: getContinentDataError
    }
    );  

}

function getContinentDataSuccess(data,textStatus,jqXHR)
{ 
    if(data != null)
    {
        L.geoJson(data, {
            onEachFeature: function(feature, layer) {
                var label = L.marker(feature.properties.labelPoint, {
                  icon: L.divIcon({
                    className: 'label',
                    html: feature.properties.continentName,
                    iconSize: [100, 40]
                  })
                }).addTo(map);
                },
                color: 'orange'}).addTo(map);
        //map.setView(continentCoord[0],2);
    }
}

function getContinentDataError(jqXHR,textStatus)
{
    alert("Error reading GeoJSON " + textStatus + " " + jqXHR);
}