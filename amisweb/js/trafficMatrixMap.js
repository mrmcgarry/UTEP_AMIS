queue()	// Will load the following instructions until after the page has loaded

.defer(d3.csv, "../data/countries.csv", function(d) {	// d3.csv will be the function that will be called when the page has finished loading
  return {
    latitude: +d.latitude,		// This callback functions modifies the content generated by d3.csv, in this case it parses all the numbers
    longitude: +d.longitude,
	name: d.name
  };
})
.defer(d3.json, "../data/instrumentData2.json") // d3.json will automatically parse the json object so no callback is necessary in this case
.await(function(error, file1, file2) { 	// Sets the callback to be invoked when all deferred tasks have finished, i.e., the callback function will execute after d3.csv and its callback are executed.

	if(error)
		alert("Something went wrong! :( " + error);	// Alert of any errors with the retrieving of data.

	//console.log(file2);		// Log the resulting JSON object that results from the defered d3.csv method.
	
	var countryCoordData = file1; // The first file that was transferred is the geological position for the countries
	
	var continentCoordData = [
			{latitude: 2.0000003, longitude: 15.9999997, name: "Africa"},
			{latitude: -82.108182, longitude: 34.378236, name: "Antarctica"},
			{latitude: 56.0000002, longitude: 103.9999998, name: "Asia"},
			{latitude:  51.0000003, longitude: 9.9999997, name: "Europe"},
			{latitude: 51.0000002, longitude: -109.0000002, name: "North America"},
			{latitude: -18.3128, longitude: 138.5156, name: "Oceania"},
			{latitude: -21.0002179, longitude: -61.0006565, name: "South America"},
		];
	
	var jason = file2;	// The second file is the actual data
	
	/* var section = "continentMatrixByte",	// The section of the data that will be represented on the map
		sectionLabel = "continentLbl",		// The label data
		coordinates = continentCoordData,
		
		traffic = buildHash (jason, section, sectionLabel, coordinates); // Builds the data matrix as an array of objects that will then be represented on the map
 */	
	var section = "asMatrixByte",	// The section of the data that will be represented on the map
		sectionLabel = "asnumOrgname",		// The label data
	
		traffic = buildHash (jason,section,sectionLabel);
	
	mymap = renderMap('mapContainer',0,0,2);	// Render the map at lat: 0, long: 0 and zoom level: 2
	drawTrafficPaths (traffic, mymap, { weightRange: [3, 20], diameterRange: [3, 10000] });

	//drawMatrix ('#matrixcontainer',traffic );
	
	// mymap.on('moveend', function(){ console.log(mymap.getCenter(), mymap.getZoom(), mymap.getBounds()); })

});

function buildHash ( data, matrix, matrixLabel, coordinateData ) {
	
	var results = [];
		
	function searchCoordinate (term) {
		// SEARCH
		var latlong = [];
		
		for (var j=0; j<coordinateData.length; j++)
		{
			if (coordinateData[j].name === term){
				//latlong = new L.LatLng(coordinateData[j].latitude, coordinateData[j].longitude);
				latlong = [coordinateData[j].latitude, coordinateData[j].longitude];
				break;
			}
			else if (coordinateData[j].name === null){
				latlong = [0,0];
				break;
			}
		}
		return latlong;
	}
	
	if (matrix === 'asMatrixByte'){
		for (var y=0; y<data[matrix].length; y++){
			for (var x=0; x<data[matrix][y].length; x++){				
				results.push({ SrcLabel: data[matrixLabel][y], DstLabel: data[matrixLabel][x], Bytes: data[matrix][y][x],
					SrcLatitude: data['asnumLatitude'][y], 
					SrcLongitude: data['asnumLongitude'][y],
					DstLatitude: data['asnumLatitude'][x],
					DstLongitude: data['asnumLongitude'][x],
					/* SrcCoords: searchCoordinate(data[matrixLabel][y]),
					DstCoords: searchCoordinate(data[matrixLabel][x]), */
					X: x, Y: y, offset: (x > y)? 10: 0,
					SrcPort: { Bytes: (data['asMatrixSrcPortHist'])? data['asMatrixSrcPortHist'][y][x] : 'undefined', Ports: data['srcPortNumbers'] },
					DstPort: { Bytes: (data['asMatrixDstPortHist'])? data['asMatrixDstPortHist'][y][x] : 'undefined', Ports: data['dstPortNumbers'] }
				});
			}
		}
	}
	else{
		var srclatlong, dstlatlong;
		
		for (var y=0; y<data[matrix].length; y++){
			for (var x=0; x<data[matrix][y].length; x++){
				srclatlong = searchCoordinate(data[matrixLabel][y]);
				dstlatlong = searchCoordinate(data[matrixLabel][x]);
				
				results.push({ SrcLabel: data[matrixLabel][y], DstLabel: data[matrixLabel][x], Bytes: data[matrix][y][x],
					SrcLatitude: srclatlong[0], 
					SrcLongitude: srclatlong[1],
					DstLatitude: dstlatlong[0],
					DstLongitude: dstlatlong[1],
					/* SrcCoords: searchCoordinate(data[matrixLabel][y]),
					DstCoords: searchCoordinate(data[matrixLabel][x]), */
					X: x, Y: y, offset: (x > y)? 10: 0,
					SrcPort: { Bytes: (matrix === "continentMatrixByte")? data['continentMatrixSrcPortHist'][y][x] : data['countryMatrixSrcPortHist'][y][x], Ports: data['srcPortNumbers'] },
					DstPort: { Bytes: (matrix === "continentMatrixByte")? data['continentMatrixDstPortHist'][y][x] : data['countryMatrixDstPortHist'][y][x], Ports: data['dstPortNumbers'] }
					});
				
			}
		}
	}
	console.log(results);
	
	return results;
}

function renderMap ( container, viewlat, viewlong, zoom ) {
	
	var mymap = L.map(container).setView([viewlat, viewlong], zoom);
	
	/* L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/streets-v9/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiZ2Vlc2VlIiwiYSI6ImNpcndxMDh5bDAwMGgyeGxoaGFjdzZqMzIifQ.7u3MyHgEwoJi9J11mgQHGw', {
    attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="http://mapbox.com">Mapbox</a>',
    maxZoom: 18,
	}).addTo(mymap); */
	
	L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
	}).addTo(mymap);
	
	//getContinentData();
	
	return mymap;
	
}

function drawTrafficPaths ( trafficData, map, options ) {
	
	var weightScale = d3.scale.log()
		.domain([1, d3.max(trafficData, function (d){ return d.Bytes; })]) 
		.range([options.weightRange[0], options.weightRange[1]]), //3, 20
	
	colourScale = d3.scale.category10(),
	
	diameterScale = d3.scale.log()
		.domain([1, d3.max(trafficData, function (d){ return d.Bytes; })]) 
		.range([options.diameterRange[0], options.diameterRange[1]]); //3, 1000000
	
	var pointsList = [];
	var markerList = [];
	var polyLineList = [];
	var circlesList = [];
	var animatedMarker = [];
	
	for (var i = 0; i<trafficData.length; i++){
		if(trafficData[i].SrcLatitude === undefined || trafficData[i].DstLatitude === undefined || trafficData[i].SrcLongitude === undefined || trafficData[i].DstLongitude === undefined)
			console.log("Undefined coordinates, data skipped. " + "Check spelling on '" + trafficData[i].SrcLabel + "'or '" + trafficData[i].DstLabel + "'.");
		else{
			pointsList.push([new L.LatLng(trafficData[i].SrcLatitude, trafficData[i].SrcLongitude),
							 new L.LatLng(trafficData[i].DstLatitude, trafficData[i].DstLongitude)]);
			/* pointsList.push([trafficData[i].SrcCoords, trafficData[i].DstCoords]); */
		}
	}
	
	for (i = 0; i<trafficData.length; i++){
		if(trafficData[i].SrcLatitude === undefined || trafficData[i].DstLatitude === undefined || trafficData[i].SrcLongitude === undefined || trafficData[i].DstLongitude === undefined)
			console.log("No Path Drawn!" + "(" + trafficData[i].SrcLabel + " to " + trafficData[i].DstLabel + ")");
		else{
			if(trafficData[i].SrcLatitude === trafficData[i].DstLatitude && trafficData[i].SrcLongitude === trafficData[i].DstLongitude && trafficData[i].Bytes)
			//if(trafficData[i].SrcCoords === trafficData[i].DstCoords && trafficData[i].Bytes)
			{
				circlesList.push(new L.circle(pointsList[i][0], diameterScale(trafficData[i].Bytes), {
					color: colourScale(trafficData[i].Bytes),
					fillColor: colourScale(trafficData[i].Bytes),
					fillOpacity: 0.5,
					data: trafficData[i]
				}).bindPopup(trafficData[i].Bytes.toString() + ' bytes within ' + trafficData[i].SrcLabel + '.')/* .addTo(map) */);
			}	
			else if (trafficData[i].Bytes)
			{
				polyLineList.push( new L.Polyline(pointsList[i], {
					color: colourScale(trafficData[i].Bytes),
					weight: weightScale(trafficData[i].Bytes),
					opacity: 0.06,
					smoothFactor: 1,
					offset: trafficData[i].offset,
					data: trafficData[i]
				}).bindPopup(trafficData[i].Bytes.toString() + ' bytes from ' + trafficData[i].SrcLabel + ' to ' + trafficData[i].DstLabel + '.'))/* .addTo(map) */;
			}
		}
	}
	
	function compare(a,b) {
	  if (a._mRadius > b._mRadius)
		return -1;
	  if (a._mRadius < b._mRadius)
		return 1;
	  return 0;
	}
	
	circlesList.sort(compare);
	for (i=0;i<circlesList.length;i++)
	{
		circlesList[i]
		.on('click', function(e){
			console.log(e.target);
			
			var datax = e.target.options.data.SrcPort.Ports;
			var datay = e.target.options.data.SrcPort.Bytes;
			
			plotHistogramRaw( 0.1, "Port Number", "Bytes", datax, datay );
			
		})
		.addTo(map);
		
		//circlesList[i].addTo(map);
	}
	
	for (i=0;i<polyLineList.length;i++)
	{
		polyLineList[i].on('mouseover', function(e){
			var layer = e.target;

			layer.setStyle({
				opacity: 0.8
			});
		})
		.on('mouseout', function(e){
			var layer = e.target;

			layer.setStyle({
				opacity: 0.06
			});
		})
		.on('click', function(e){
			console.log(e.target);
			
			var datax = e.target.options.data.SrcPort.Ports;
			var datay = e.target.options.data.SrcPort.Bytes;
			
			plotHistogramRaw( 0.1, "Port Number", "Bytes", datax, datay );
			
		})
		.addTo(map);
		
		/* decoratorList[i] = new L.polylineDecorator(polyLineList[i], {
					patterns: [
								{offset: 0, repeat: 75, symbol: L.Symbol.arrowHead({pixelSize: 20})}
							  ]}).addTo(map); */
	}
	
	function bindPolyline(e) {
		// SEARCH
		var searchResults = [],
			searchTerm = e.target.getLatLng(),
			compare = [];
		
		for(var i=0;i<polyLineList.length;i++)
		{
			compare = polyLineList[i]._latlngs;
			if (compare[0].equals(searchTerm) || compare[1].equals(searchTerm))
				searchResults.push(polyLineList[i]);
		}
		//console.log(searchResults);
		return searchResults;
	}
	
	i = 0;
	while(trafficData[i].Y === 0)
	{
		markerList[i] = new L.marker(pointsList[i][1], { riseOnHover: true, riseOffset: 200 }).bindPopup(trafficData[i].DstLabel).on('popupopen', function(e){
			var polylines = bindPolyline(e),
				offsetvalue;
				
			var myIcon = L.icon({
				iconUrl: 'http://geopole.free.fr/exemples/geoportail/jQGeoportail-0/img/marker-icon-purple.png',
				//iconRetinaUrl: 'my-icon@2x.png',
				iconSize: [25, 41],
				iconAnchor: [12.5, 41],
				//popupAnchor: [-3, -76],
				//shadowUrl: 'my-icon-shadow.png',
				//shadowRetinaUrl: 'my-icon-shadow@2x.png',
				//shadowSize: [68, 95],
				//shadowAnchor: [22, 94]
			});
			//console.log(polylines[0].getLatLngs(), L.PolylineOffset.offsetLatLngs(polylines[0].getLatLngs(),10,map));
			for(var i=0;i<polylines.length;i++){
				offsetvalue = polylines[i].options.offset;
				polylines[i].setStyle({
					//opacity: (+polylines[i]._path.attributes['stroke-opacity'].nodeValue === 1) ? 0.06 : 1
					opacity: 0.8
				});
				
				animatedMarker.push(L.Marker.movingMarker(L.PolylineOffset.offsetLatLngs(polylines[i].getLatLngs(),offsetvalue,map), [2000], {
					//onEnd: function() { map.removeLayer(this); },
					//interval: 500
					icon: myIcon,
					autostart: true,
					loop: true
				}));
				for (var j=0;j<animatedMarker.length;j++)
					animatedMarker[j].addTo(map);
			}
			
			
			
		})
		.on('popupclose', function(e){
			//console.log(animatedMarker);
			for (var j=0;j<animatedMarker.length;j++)
				map.removeLayer(animatedMarker[j]);
			animatedMarker = [];
			var polylines = bindPolyline(e);
			for(var i=0;i<polylines.length;i++){
				polylines[i].setStyle({
					//opacity: (+polylines[i]._path.attributes['stroke-opacity'].nodeValue === 1) ? 0.06 : 1
					opacity: 0.06
				});
			}
		}).addTo(map);
		
		i++;
	}
	
	
	//console.log("points", pointsList);
	//console.log("paths", polyLineList);
	//console.log("markers", markerList);
	
}

function drawMatrix ( container, trafficData ) {
	
	var uniqueNames = [];
	
	for ( var i = 0; i<trafficData.length; i++ ){
		uniqueNames.push(trafficData[i].SrcLabel);
	}
	
	$.uniqueSort(uniqueNames);

	var weightScale = d3.scale.log()
		.domain([1, d3.max(trafficData, function (d){ return d.Bytes; })]) 
		.range([0.1, 1]),
		
		colourScale = d3.scale.category10(),
		
		nameScaleSize = trafficData.length * 4.2,
		nameScale = d3.scale.ordinal()
					.domain(uniqueNames)
					.rangePoints([0,nameScaleSize],1);
	
	var svg = d3.select(container)
		.append("svg")
		.attr("height", 2000)
		.attr("width", 2000)
		.attr("id", "matrixsvg");
		
/* 	svg.append("rect")
		.attr("width", 500)
		.attr("height", 500)
		.attr("fill", "rgba(100,100,100,0.4)")
		.attr("class", "backgroundColor"); */
		
	var g = svg.append("g")
		.attr("transform", "translate(150,150)")
		.attr("id", "adjacencyG");
		
	g.selectAll("rect")
		.data(trafficData)
		.enter()
		.append("rect")
		.attr("class", "grid")
		.attr("width", 25)
		.attr("height", 25)
		.attr("x", function (d) { return d.X * 30 })
		.attr("y", function (d) { return d.Y * 30 })
		.attr("fill", function (d) { return (d.Bytes) ? "purple" : "blue" })
		.attr("stroke", function (d) { return (d.Bytes) ? "purple" : "blue" })
		.attr("rx", 5)
		.attr("ry", 5)
		.style("fill-opacity", function (d) { return weightScale(d.Bytes); } )
		.on("mouseover", showLabel)
		.on("mouseout", clearLabel);
			
	function showLabel (d) {
		g.append("text")
			.attr("class", "mlabel")
			.attr("x", d.X * 30 )
			.attr("y", d.Y * 30 )
			.attr("text-anchor", "middle")
			.text(d.Bytes)
			.attr("transform", "translate(13,17)");
	}
	
	function clearLabel (d) {
		d3.select(".mlabel").remove();
	}
	
	var xAxis = d3.svg.axis().scale(nameScale).orient("top").tickSize(0),   
		yAxis = d3.svg.axis().scale(nameScale).orient("left").tickSize(0);    
	
	d3.select("#adjacencyG").append("g").call(xAxis).selectAll("text").style("text-anchor", "start").attr("transform", "translate(10, -10) rotate(-90)");
	d3.select("#adjacencyG").append("g").call(yAxis);
}

function getContinentData()
{
    // Obtain the continent geojson file from the data directory
    $.ajax(
    {
        type: "GET",
        url: "data/continents.json",
        dataType: "json",
        success: getContinentDataSuccess,
        error: getContinentDataError
    }
    );  

}

function getContinentDataSuccess(data,textStatus,jqXHR)
{ 
    if(data != null)
    {
        L.geoJson(data, {
            onEachFeature: function(feature, layer) {
                var label = L.marker(feature.properties.labelPoint, {
                  icon: L.divIcon({
                    className: 'label',
                    html: feature.properties.continentName,
                    iconSize: [100, 40]
                  })
                }).addTo(map);
                },
                color: 'orange'}).addTo(map);
        //map.setView(continentCoord[0],2);
    }
}

function getContinentDataError(jqXHR,textStatus)
{
    alert("Error reading GeoJSON " + textStatus + " " + jqXHR);
}